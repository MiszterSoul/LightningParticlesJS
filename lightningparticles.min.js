class LightningParticle{constructor(i,t={}){this.canvas=i,this.ctx=i.getContext("2d"),this.config={particleColor:t.particleColor??"#4a4a4a",particleOpacity:t.particleOpacity??.8,particleMinSize:t.particleMinSize??.5,particleMaxSize:t.particleMaxSize??2,particleSpeed:t.particleSpeed??1,lineColor:t.lineColor??"#ffffff",lineOpacity:t.lineOpacity??.6,lineThickness:t.lineThickness??.5,maxDistance:t.maxDistance??50,lightningColor:t.lightningColor??"#00ffff",lightningGlowColor:t.lightningGlowColor??"#00ffff",lightningOpacity:t.lightningOpacity??.8,lightningThickness:t.lightningThickness??2,lightningFrequency:t.lightningFrequency??.03,lightningGlow:t.lightningGlow??100,globalLightningDirection:t.globalLightningDirection??!1,lightningAngle:t.lightningAngle??Math.PI/2,lightningThroughParticles:t.lightningThroughParticles??!0,minLightningSegments:t.minLightningSegments??3,maxLightningSegments:t.maxLightningSegments??20,enableSplits:t.enableSplits??!0,minSplitSegments:t.minSplitSegments??3,maxSplits:t.maxSplits??3,splitProbability:t.splitProbability??.3,minLightningLifetime:t.minLightningLifetime??30,maxLightningLifetime:t.maxLightningLifetime??60,instantLightning:t.instantLightning??!1,backgroundColor:t.backgroundColor??"rgba(0, 0, 0, 0.75)",particleBlendMode:t.particleBlendMode??"source-over",lightningBlendMode:t.lightningBlendMode??"source-over",fpsLimit:t.fpsLimit??60,pauseOnBlur:t.pauseOnBlur??!0,referenceResolution:t.referenceResolution??{width:1920,height:1080},referenceParticleCount:t.referenceParticleCount??350,minParticleCount:t.minParticleCount??25,maxParticleCount:t.maxParticleCount??1500,minFPS:t.minFPS??5,maxFPS:t.maxFPS??144,particleAdjustStep:t.particleAdjustStep??15,pauseOnScroll:t.pauseOnScroll??!1},this.particles=[],this.lightning=[],this.lastTime=0,this.deltaTime=0,this.fpsInterval=1e3/this.config.fpsLimit,this.fps=0,this.frameCount=0,this.lastFpsUpdate=performance.now(),this.isRunning=!0,this.isPaused=!1,this.isScrollPaused=!1,this.resize=this.resize.bind(this),this.animate=this.animate.bind(this),this.handleVisibilityChange=this.handleVisibilityChange.bind(this),this.handleFocus=this.handleFocus.bind(this),this.handleBlur=this.handleBlur.bind(this),this.handleScroll=this.handleScroll.bind(this),this.setupEventListeners(),this.resize(),requestAnimationFrame(this.animate)}setupEventListeners(){window.addEventListener("resize",this.resize),document.addEventListener("visibilitychange",this.handleVisibilityChange),window.addEventListener("focus",this.handleFocus),window.addEventListener("blur",this.handleBlur),this.config.pauseOnScroll&&(this.observer=new IntersectionObserver((i=>{i.forEach((i=>{i.isIntersecting?(this.resume(),this.isScrollPaused=!1):(this.pause(),this.isScrollPaused=!0)}))}),{threshold:0}),this.observer.observe(this.canvas))}removeEventListeners(){window.removeEventListener("resize",this.resize),document.removeEventListener("visibilitychange",this.handleVisibilityChange),window.removeEventListener("focus",this.handleFocus),window.removeEventListener("blur",this.handleBlur),this.config.pauseOnScroll&&window.removeEventListener("scroll",this.handleScroll),this.config.pauseOnScroll&&this.observer&&(this.observer.disconnect(),this.observer=null)}resize(){try{this.canvas.width=this.canvas.clientWidth,this.canvas.height=this.canvas.clientHeight;const i=this.canvas.width*this.canvas.height,t=this.config.referenceResolution.width*this.config.referenceResolution.height,e=this.config.referenceParticleCount/t;let s=Math.round(e*i);for(s=Math.max(this.config.minParticleCount,Math.min(s,this.config.maxParticleCount)),this.config.particleCount=s,this.particles.forEach((i=>{i.x=Math.max(0,Math.min(i.x,this.canvas.width)),i.y=Math.max(0,Math.min(i.y,this.canvas.height))}));this.particles.length>this.config.particleCount;)this.particles.pop();for(;this.particles.length<this.config.particleCount;)this.createParticle()}catch(i){}}createParticle(){this.particles.push({x:Math.random()*this.canvas.width,y:Math.random()*this.canvas.height,radius:Math.random()*(this.config.particleMaxSize-this.config.particleMinSize)+this.config.particleMinSize,color:this.config.particleColor,velocity:{x:(Math.random()-.5)*this.config.particleSpeed*2,y:(Math.random()-.5)*this.config.particleSpeed*2}})}updateParticles(){const i=this.deltaTime/(1e3/60);this.particles.forEach((t=>{t.x+=t.velocity.x*i,t.y+=t.velocity.y*i,t.x<0&&(t.x=0,t.velocity.x*=-1),t.x>this.canvas.width&&(t.x=this.canvas.width,t.velocity.x*=-1),t.y<0&&(t.y=0,t.velocity.y*=-1),t.y>this.canvas.height&&(t.y=this.canvas.height,t.velocity.y*=-1)}))}drawParticles(){try{this.ctx.globalCompositeOperation=this.config.particleBlendMode,this.ctx.globalAlpha=this.config.particleOpacity,this.ctx.fillStyle=this.config.particleColor,this.particles.forEach((i=>{this.ctx.beginPath(),this.ctx.arc(i.x,i.y,i.radius,0,2*Math.PI),this.ctx.fill()})),this.ctx.globalAlpha=1,this.ctx.globalCompositeOperation="source-over"}catch(i){}}connectParticles(){try{this.ctx.globalAlpha=this.config.lineOpacity,this.ctx.strokeStyle=this.config.lineColor,this.ctx.lineWidth=this.config.lineThickness;const i=this.config.maxDistance**2;for(let t=0;t<this.particles.length;t++)for(let e=t+1;e<this.particles.length;e++){const s=this.particles[t].x-this.particles[e].x,n=this.particles[t].y-this.particles[e].y;s*s+n*n<i&&(this.ctx.beginPath(),this.ctx.moveTo(this.particles[t].x,this.particles[t].y),this.ctx.lineTo(this.particles[e].x,this.particles[e].y),this.ctx.stroke())}this.ctx.globalAlpha=1}catch(i){}}findClosestParticle(i,t){let e=1/0,s=null;for(const n of this.particles){const h=n.x-i,a=n.y-t,l=h*h+a*a;l<e&&(e=l,s=n)}return s}createLightning(i=null,t=null,e=null){try{if(0===this.particles.length)return;let s=null!==i?i:this.particles[Math.floor(Math.random()*this.particles.length)].x,n=null!==t?t:this.particles[Math.floor(Math.random()*this.particles.length)].y;const h=[{x:s,y:n}];let a=this.config.globalLightningDirection?this.config.lightningAngle:Math.random()*Math.PI*2;const l=null!==e?e:Math.floor(Math.random()*(this.config.maxLightningSegments-this.config.minLightningSegments+1))+this.config.minLightningSegments;for(let i=0;i<l;i++){const t=30*Math.random()+20;let c=s+Math.cos(a)*t,o=n+Math.sin(a)*t;if(this.config.lightningThroughParticles){const i=this.findClosestParticle(c,o);i&&(c=i.x,o=i.y)}if(h.push({x:c,y:o}),this.config.enableSplits&&Math.random()<this.config.splitProbability&&null===e){const t=Math.floor(Math.random()*(l-i-this.config.minSplitSegments))+this.config.minSplitSegments;this.createLightning(c,o,t)}if(this.config.globalLightningDirection||(a+=(Math.random()-.5)*Math.PI/4),s=c,n=o,s<0||s>this.canvas.width||n<0||n>this.canvas.height)break}const c=Math.floor(Math.random()*(this.config.maxLightningLifetime-this.config.minLightningLifetime+1))+this.config.minLightningLifetime;this.lightning.push({points:h,alpha:this.config.lightningOpacity,lifetime:c,currentLifetime:0})}catch(i){}}drawLightning(){try{this.ctx.globalCompositeOperation=this.config.lightningBlendMode,this.ctx.strokeStyle=this.config.lightningColor,this.ctx.lineWidth=this.config.lightningThickness,this.ctx.lineCap="round",this.ctx.lineJoin="round",this.lightning.forEach(((i,t)=>{let e;if(this.ctx.save(),this.ctx.beginPath(),this.ctx.moveTo(i.points[0].x,i.points[0].y),this.config.instantLightning)e=i.points.length;else{const t=i.currentLifetime/i.lifetime;e=Math.floor(t*i.points.length)}for(let t=1;t<e;t++)this.ctx.lineTo(i.points[t].x,i.points[t].y);this.ctx.shadowColor=this.config.lightningGlowColor,this.ctx.shadowBlur=this.config.lightningGlow,this.ctx.shadowOffsetX=0,this.ctx.shadowOffsetY=0,i.alpha=this.config.lightningOpacity*(1-i.currentLifetime/i.lifetime),this.ctx.globalAlpha=i.alpha,this.ctx.stroke(),this.ctx.restore(),i.currentLifetime++,i.currentLifetime>=i.lifetime&&this.lightning.splice(t,1)})),this.ctx.globalAlpha=1,this.ctx.globalCompositeOperation="source-over"}catch(i){}}drawBackground(){this.ctx.fillStyle=this.config.backgroundColor,this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height)}animate(i){try{if(!this.isRunning)return;if(requestAnimationFrame(this.animate),this.isPaused)return;this.deltaTime=Math.min(i-this.lastTime,100),this.frameCount++;const t=performance.now(),e=t-this.lastFpsUpdate;if(e>=1e3)if(this.fps=this.frameCount/e*1e3,this.frameCount=0,this.lastFpsUpdate=t,this.fps<this.config.minFPS&&this.particles.length>this.config.minParticleCount)for(let i=0;i<this.config.particleAdjustStep;i++)this.particles.length>this.config.minParticleCount&&this.particles.pop();else if(this.fps>this.config.maxFPS&&this.particles.length<this.config.maxParticleCount)for(let i=0;i<this.config.particleAdjustStep;i++)this.particles.length<this.config.particleCount&&this.createParticle();if(i-this.lastTime<this.fpsInterval)return;this.lastTime=i,this.drawBackground(),this.config.lightningOpacity>0&&Math.random()<this.config.lightningFrequency&&this.createLightning(),this.drawLightning(),this.particles.length<this.config.particleCount&&this.createParticle(),this.updateParticles(),this.connectParticles(),this.drawParticles()}catch(i){}}updateConfig(i){for(Object.assign(this.config,i),this.fpsInterval=1e3/this.config.fpsLimit,this.lightning=[];this.particles.length>this.config.particleCount;)this.particles.pop();for(;this.particles.length<this.config.particleCount;)this.createParticle();if(this.particles.length<this.config.minParticleCount)for(;this.particles.length<this.config.minParticleCount;)this.createParticle();else if(this.particles.length>this.config.maxParticleCount)for(;this.particles.length>this.config.maxParticleCount;)this.particles.pop()}pause(){this.isPaused=!0}resume(){this.isPaused&&(this.isPaused=!1,this.lastTime=performance.now(),this.particles.forEach((i=>{i.x=Math.random()*this.canvas.width,i.y=Math.random()*this.canvas.height})))}stop(){this.isRunning=!1,this.removeEventListeners(),this.particles=[],this.lightning=[],this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height)}handleVisibilityChange(){if(document.hidden&&this.config.pauseOnBlur)this.pause();else if(!document.hidden&&this.config.pauseOnBlur){const i=this.canvas.clientWidth,t=this.canvas.clientHeight;this.canvas.width===i&&this.canvas.height===t||this.resize(),this.lastTime=performance.now(),this.resume()}}handleFocus(){this.config.pauseOnBlur&&this.resume()}handleBlur(){this.config.pauseOnBlur&&this.pause()}handleScroll(){const i=this.canvas.getBoundingClientRect(),t=Math.max(document.documentElement.clientHeight,window.innerHeight),e=!(i.bottom<0||i.top-t>=0);e&&this.isScrollPaused?(this.resume(),this.isScrollPaused=!1):e||this.isScrollPaused||(this.pause(),this.isScrollPaused=!0)}}