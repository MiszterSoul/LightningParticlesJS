class LightningParticle{constructor(canvas,config={}){this.canvas=canvas,this.ctx=canvas.getContext("2d"),this.config={particleColor:config.pparticleColor??"#4a4a4a",particleOpacity:config.particleOpacity??.8,particleCount:config.particleCount??350,particleMinSize:config.particleMinSize??.5,particleMaxSize:config.particleMaxSize??2,particleSpeed:config.particleSpeed??1,lineColor:config.lineColor??"#ffffff",lineOpacity:config.lineOpacity??.6,lineThickness:config.lineThickness??.5,maxDistance:config.maxDistance??50,lightningColor:config.lightningColor??"#00ffff",lightningGlowColor:config.lightningGlowColor??"#00ffff",lightningOpacity:config.lightningOpacity??.8,lightningThickness:config.lightningThickness??2,lightningFrequency:config.lightningFrequency??.03,lightningGlow:config.lightningGlow??100,globalLightningDirection:config.globalLightningDirection??!1,lightningAngle:config.lightningAngle??Math.PI/2,lightningThroughParticles:config.lightningThroughParticles??!0,minLightningSegments:config.minLightningSegments??3,maxLightningSegments:config.maxLightningSegments??20,enableSplits:config.enableSplits??!0,minSplitSegments:config.minSplitSegments??3,maxSplits:config.maxSplits??3,splitProbability:config.splitProbability??.3,minLightningLifetime:config.minLightningLifetime??30,maxLightningLifetime:config.maxLightningLifetime??60,instantLightning:config.instantLightning??!1,minActiveLightning:config.minActiveLightning??1,maxActiveLightning:config.maxActiveLightning??5,backgroundColor:config.backgroundColor??"rgba(0, 0, 0, 0.75)",particleBlendMode:config.particleBlendMode??"screen",lightningBlendMode:config.lightningBlendMode??"screen",fpsLimit:config.fpsLimit??60,pauseOnBlur:config.pauseOnBlur??!0},this.particles=[],this.lightning=[],this.lastTime=0,this.deltaTime=0,this.fpsInterval=1e3/this.config.fpsLimit,this.resize=this.resize.bind(this),this.animate=this.animate.bind(this),this.handleVisibilityChange=this.handleVisibilityChange.bind(this),this.handleFocus=this.handleFocus.bind(this),this.handleBlur=this.handleBlur.bind(this),this.resize(),window.addEventListener("resize",this.resize),document.addEventListener("visibilitychange",this.handleVisibilityChange),window.addEventListener("focus",this.handleFocus),window.addEventListener("blur",this.handleBlur),this.isRunning=!0,requestAnimationFrame(this.animate)}resize(){this.canvas.width=this.canvas.offsetWidth,this.canvas.height=this.canvas.offsetHeight,this.particles.forEach(particle=>{particle.x>this.canvas.width&&(particle.x=this.canvas.width),particle.y>this.canvas.height&&(particle.y=this.canvas.height)});for(;this.particles.length<this.config.particleCount;)this.createParticle()}createLightning(startX=null,startY=null,remainingSegments=null){if(0===this.particles.length)return;let x=null!==startX?startX:this.particles[Math.floor(Math.random()*this.particles.length)].x,y=null!==startY?startY:this.particles[Math.floor(Math.random()*this.particles.length)].y,points=[{x,y}],angle=this.config.globalLightningDirection?this.config.lightningAngle:Math.random()*Math.PI*2,segments=null!==remainingSegments?remainingSegments:Math.floor(Math.random()*(this.config.maxLightningSegments-this.config.minLightningSegments+1))+this.config.minLightningSegments;for(let i=0;i<segments;i++){let length=Math.random()*30+20,newX=x+Math.cos(angle)*length,newY=y+Math.sin(angle)*length;if(this.config.lightningThroughParticles){let closestParticle=this.findClosestParticle(newX,newY);closestParticle&&(newX=closestParticle.x,newY=closestParticle.y)}if(points.push({x:newX,y:newY}),this.config.enableSplits&&Math.random()<this.config.splitProbability&&null===remainingSegments){let splitSegments=Math.floor(Math.random()*(segments-i-this.config.minSplitSegments))+this.config.minSplitSegments;this.createLightning(newX,newY,splitSegments)}this.config.globalLightningDirection||(angle+=(Math.random()-.5)*Math.PI/4),x=newX,y=newY;if(x<0||x>this.canvas.width||y<0||y>this.canvas.height)break}const lifetime=Math.floor(Math.random()*(this.config.maxLightningLifetime-this.config.minLightningLifetime+1))+this.config.minLightningLifetime;this.lightning.push({points,alpha:this.config.lightningOpacity,maxAlpha:Math.random()*.5+.5,lifetime,currentLifetime:0})}findClosestParticle(x,y){let closestDist=1/0,closestParticle=null;for(let particle of this.particles){let dist=Math.hypot(particle.x-x,particle.y-y);dist<closestDist&&(closestDist=dist,closestParticle=particle)}return closestParticle}drawLightning(){this.ctx.globalCompositeOperation=this.config.lightningBlendMode,this.ctx.strokeStyle=this.config.lightningColor,this.ctx.lineWidth=this.config.lightningThickness,this.ctx.lineCap="round",this.ctx.lineJoin="round",this.lightning.forEach((bolt,index)=>{this.ctx.save(),this.ctx.beginPath(),this.ctx.moveTo(bolt.points[0].x,bolt.points[0].y);let segmentCount;if(this.config.instantLightning)segmentCount=bolt.points.length;else{const progress=bolt.currentLifetime/bolt.lifetime;segmentCount=Math.floor(progress*bolt.points.length)}for(let i=1;i<segmentCount;i++)this.ctx.lineTo(bolt.points[i].x,bolt.points[i].y);this.ctx.shadowColor=this.config.lightningGlowColor,this.ctx.shadowBlur=this.config.lightningGlow,this.ctx.shadowOffsetX=0,this.ctx.shadowOffsetY=0,this.ctx.globalAlpha=bolt.alpha,this.ctx.stroke(),this.ctx.restore(),bolt.currentLifetime++,bolt.currentLifetime>=bolt.lifetime&&this.lightning.splice(index,1)}),this.ctx.globalAlpha=1,this.ctx.globalCompositeOperation="source-over"}createParticle(){this.particles.push({x:Math.random()*this.canvas.width,y:Math.random()*this.canvas.height,radius:Math.random()*(this.config.particleMaxSize-this.config.particleMinSize)+this.config.particleMinSize,color:this.config.particleColor,velocity:{x:(Math.random()-.5)*this.config.particleSpeed*2,y:(Math.random()-.5)*this.config.particleSpeed*2}})}updateParticles(){const scaleFactor=this.deltaTime/1e3*60;this.particles.forEach(particle=>{particle.x+=particle.velocity.x*scaleFactor,particle.y+=particle.velocity.y*scaleFactor,(particle.x<0||particle.x>this.canvas.width)&&(particle.velocity.x*=-1),(particle.y<0||particle.y>this.canvas.height)&&(particle.velocity.y*=-1)})}drawParticles(){this.ctx.globalCompositeOperation=this.config.particleBlendMode,this.ctx.fillStyle=`${this.config.particleColor}${Math.floor(255*this.config.particleOpacity).toString(16).padStart(2,"0")}`,this.particles.forEach(particle=>{this.ctx.beginPath(),this.ctx.arc(particle.x,particle.y,particle.radius,0,2*Math.PI),this.ctx.fill()}),this.ctx.globalCompositeOperation="source-over"}connectParticles(){this.ctx.strokeStyle=`${this.config.lineColor}${Math.floor(255*this.config.lineOpacity).toString(16).padStart(2,"0")}`,this.ctx.lineWidth=this.config.lineThickness;for(let i=0;i<this.particles.length;i++)for(let j=i+1;j<this.particles.length;j++){const dx=this.particles[i].x-this.particles[j].x,dy=this.particles[i].y-this.particles[j].y,distance=Math.sqrt(dx*dx+dy*dy);distance<this.config.maxDistance&&(this.ctx.beginPath(),this.ctx.moveTo(this.particles[i].x,this.particles[i].y),this.ctx.lineTo(this.particles[j].x,this.particles[j].y),this.ctx.stroke())}}drawBackground(){this.ctx.fillStyle=this.config.backgroundColor,this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height)}animate(timestamp){if(!this.isRunning)return;requestAnimationFrame(this.animate),this.isPaused||(timestamp-this.lastTime<this.fpsInterval||(this.deltaTime=timestamp-this.lastTime,this.lastTime=timestamp,this.drawBackground(),this.config.lightningOpacity>0&&Math.random()<this.config.lightningFrequency&&this.createLightning(),this.drawLightning(),this.particles.length<this.config.particleCount&&this.createParticle(),this.updateParticles(),this.connectParticles(),this.drawParticles()))}updateConfig(newConfig){Object.assign(this.config,newConfig),this.fpsInterval=1e3/this.config.fpsLimit,this.lightning=[];for(;this.particles.length>this.config.particleCount;)this.particles.pop();for(;this.particles.length<this.config.particleCount;)this.createParticle()}destroy(){this.isRunning=!1,window.removeEventListener("resize",this.resize),document.removeEventListener("visibilitychange",this.handleVisibilityChange),window.removeEventListener("focus",this.handleFocus),window.removeEventListener("blur",this.handleBlur)}handleVisibilityChange(){document.hidden?this.pause():this.resume()}handleFocus(){this.config.pauseOnBlur&&this.resume()}handleBlur(){this.config.pauseOnBlur&&this.pause()}pause(){this.isPaused=!0}resume(){this.isPaused=!1,this.lastTime=performance.now(),requestAnimationFrame(this.animate)}}